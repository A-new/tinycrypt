; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\block\hight\hight.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gen_const
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\hight\hight.c
;	COMDAT _gen_const
_TEXT	SEGMENT
_s$ = -136						; size = 136
_ci$ = 8						; size = 4
_gen_const PROC						; COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	esi
	push	edi

; 54   :     int     i, j;
; 55   :     uint8_t c;
; 56   :     
; 57   :     union {
; 58   :       uint8_t  b[128+8];
; 59   :       uint32_t w[(128+8)/4];
; 60   :     } s;
; 61   : 
; 62   :     // zero initialize s
; 63   :     memset(&s, 0, sizeof(s));

	xor	al, al
	lea	edi, DWORD PTR _s$[ebp]
	mov	ecx, 136				; 00000088H
	rep stosb

; 64   : 
; 65   :     // set initial bits
; 66   :     s.w[1] = 65537;
; 67   :     s.w[0] = s.w[1] << 8;
; 68   : 
; 69   :     // set first constant
; 70   :     // precalculated from bits of s array
; 71   :     ci[0] = 0x5A;

	mov	edi, DWORD PTR _ci$[ebp]

; 72   : 
; 73   :     for(i=1; i<128; i++) {

	xor	edx, edx
	mov	DWORD PTR _s$[ebp+4], 65537		; 00010001H
	mov	DWORD PTR _s$[ebp], 16777472		; 01000100H
	mov	BYTE PTR [edi], 90			; 0000005aH
	inc	edx
$LL6@gen_const:

; 74   :       s.b[i + 6] = s.b[i + 2] ^
; 75   :                    s.b[i - 1];

	lea	eax, DWORD PTR _s$[ebp+edx+2]
	mov	cl, BYTE PTR [eax-3]
	xor	cl, BYTE PTR [eax]
	push	6
	mov	BYTE PTR [eax+4], cl
	add	eax, 3
	pop	esi
$LL3@gen_const:

; 76   : 
; 77   :       c = s.b[i + 6];
; 78   : 
; 79   :       for(j=1; j<7; j++) {
; 80   :         c += c;

	add	cl, cl

; 81   :         c ^= s.b[i + 6 - j];

	xor	cl, BYTE PTR [eax]
	dec	eax
	dec	esi
	jne	SHORT $LL3@gen_const

; 82   :       }
; 83   :       ci[i] = c;

	mov	BYTE PTR [edx+edi], cl
	inc	edx
	cmp	edx, 128				; 00000080H
	jl	SHORT $LL6@gen_const
	pop	edi
	pop	esi

; 84   :     }
; 85   : }

	leave
	ret	0
_gen_const ENDP
_TEXT	ENDS
PUBLIC	_hight128_setkey
; Function compile flags: /Ogspy
;	COMDAT _hight128_setkey
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_i$ = 15						; size = 1
_hight128_setkey PROC					; COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 90   :     uint8_t i, j, idx;
; 91   :     w128_t  *wk, *mk;
; 92   :     uint8_t *sk;
; 93   :     
; 94   :     mk=(w128_t*)in;
; 95   :     wk=(w128_t*)out;
; 96   :     sk=(uint8_t*)out;

	mov	esi, DWORD PTR _out$[ebp]
	push	edi

; 97   :     
; 98   :     // apply key whitening
; 99   :     wk->w[0] = mk->w[3];

	mov	edi, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], eax

; 100  :     wk->w[1] = mk->w[0];

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax

; 101  : 
; 102  :     #ifdef LUT
; 103  :       memcpy(&sk[8], rc, sizeof(rc));
; 104  :     #else  
; 105  :       // generate constants
; 106  :       gen_const(&sk[8]);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	_gen_const
	pop	ecx

; 107  :     #endif
; 108  :  
; 109  :     // generate subkeys
; 110  :     for(i=0; i<8; i++) {

	mov	BYTE PTR _i$[ebp], 0
$LL6@hight128_s:

; 111  :       sk += 8;

	mov	cl, BYTE PTR _i$[ebp]
	push	8
	add	esi, 8
	neg	cl
	pop	edx
$LL3@hight128_s:

; 112  :       for(j=0; j<8; j++) {
; 113  :         idx = (j - i + 8) & 7;

	mov	al, cl
	and	al, 7

; 114  : 
; 115  :         sk[0] += mk->b[idx  ];

	movzx	eax, al
	mov	bl, BYTE PTR [eax+edi]
	add	BYTE PTR [esi], bl

; 116  :         sk[8] += mk->b[idx+8];

	mov	al, BYTE PTR [eax+edi+8]
	add	BYTE PTR [esi+8], al

; 117  :         sk++;        

	inc	esi
	inc	cl
	dec	edx
	jne	SHORT $LL3@hight128_s

; 107  :     #endif
; 108  :  
; 109  :     // generate subkeys
; 110  :     for(i=0; i<8; i++) {

	inc	BYTE PTR _i$[ebp]
	cmp	BYTE PTR _i$[ebp], 8
	jb	SHORT $LL6@hight128_s
	pop	edi
	pop	esi
	pop	ebx

; 118  :       }
; 119  :     }
; 120  : }

	pop	ebp
	ret	0
_hight128_setkey ENDP
_TEXT	ENDS
PUBLIC	_F0
; Function compile flags: /Ogspy
;	COMDAT _F0
_TEXT	SEGMENT
_x$ = 8							; size = 1
_F0	PROC						; COMDAT

; 123  :     return ROTL8(x, 1) ^ ROTL8(x, 2) ^ ROTL8(x, 7);

	movzx	ecx, BYTE PTR _x$[esp-4]
	mov	eax, ecx
	rol	al, 2
	mov	edx, ecx
	rol	dl, 1
	xor	eax, edx
	ror	cl, 1
	xor	eax, ecx

; 124  : }

	ret	0
_F0	ENDP
_TEXT	ENDS
PUBLIC	_F1
; Function compile flags: /Ogspy
;	COMDAT _F1
_TEXT	SEGMENT
_x$ = 8							; size = 1
_F1	PROC						; COMDAT

; 127  :     return ROTL8(x, 3) ^ ROTL8(x, 4) ^ ROTL8(x, 6);

	movzx	ecx, BYTE PTR _x$[esp-4]
	mov	eax, ecx
	rol	al, 4
	mov	edx, ecx
	rol	dl, 3
	xor	eax, edx
	ror	cl, 2
	xor	eax, ecx

; 128  : }

	ret	0
_F1	ENDP
_TEXT	ENDS
PUBLIC	_hight128_encrypt
; Function compile flags: /Ogspy
;	COMDAT _hight128_encrypt
_TEXT	SEGMENT
tv317 = 8						; size = 4
_data$ = 8						; size = 4
_keys$ = 12						; size = 4
_hight128_encrypt PROC					; COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp

; 132  :     int      i;
; 133  :     w64_t    *x;
; 134  :     uint8_t  *sk, *wk=(uint8_t*)keys;
; 135  : 
; 136  :     x  = (w64_t*)data;
; 137  :     sk = &wk[8];

	mov	eax, DWORD PTR _keys$[ebp]

; 138  : 
; 139  :     // mix key with 1st 4 bytes
; 140  :     x->b[0] += wk[0]; x->b[2] ^= wk[1];

	mov	cl, BYTE PTR [eax]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _data$[ebp]
	add	BYTE PTR [esi], cl
	mov	cl, BYTE PTR [eax+1]
	xor	BYTE PTR [esi+2], cl

; 141  :     x->b[4] += wk[2]; x->b[6] ^= wk[3];

	mov	cl, BYTE PTR [eax+2]
	add	BYTE PTR [esi+4], cl
	push	edi
	lea	edi, DWORD PTR [eax+8]
	mov	al, BYTE PTR [eax+3]
	xor	BYTE PTR [esi+6], al
	mov	DWORD PTR tv317[ebp], 32		; 00000020H
$LL3@hight128_e:

; 142  : 
; 143  :     for(i=0; i<32; i++) {
; 144  :       x->q = ROTR64(x->q, 56);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	edx, ecx
	shld	ecx, eax, 8
	shl	eax, 8
	shr	edx, 24					; 00000018H
	or	edx, eax
	mov	DWORD PTR [esi], edx

; 145  :       // apply linear/non-linear operations
; 146  :       x->b[2] += (F1(x->b[1]) ^ *sk++);

	movzx	eax, BYTE PTR [esi+1]
	xor	ebx, ebx
	or	ebx, ecx
	push	eax
	mov	DWORD PTR [esi+4], ebx
	call	_F1
	xor	al, BYTE PTR [edi]
	add	BYTE PTR [esi+2], al

; 147  :       x->b[4] ^= (F0(x->b[3]) + *sk++);

	mov	al, BYTE PTR [esi+3]
	mov	cl, al
	rol	cl, 2
	mov	dl, al
	ror	dl, 1
	xor	cl, dl
	rol	al, 1
	xor	cl, al

; 148  :       x->b[6] += (F1(x->b[5]) ^ *sk++);

	movzx	eax, BYTE PTR [esi+5]
	add	cl, BYTE PTR [edi+1]
	push	eax
	xor	BYTE PTR [esi+4], cl
	call	_F1
	xor	al, BYTE PTR [edi+2]
	pop	ecx
	add	BYTE PTR [esi+6], al

; 149  :       x->b[0] ^= (F0(x->b[7]) + *sk++);

	mov	al, BYTE PTR [esi+7]
	pop	ecx
	mov	cl, al
	rol	cl, 2
	mov	dl, al
	ror	dl, 1
	xor	cl, dl
	rol	al, 1
	xor	cl, al
	add	cl, BYTE PTR [edi+3]
	xor	BYTE PTR [esi], cl
	add	edi, 4
	dec	DWORD PTR tv317[ebp]
	jne	SHORT $LL3@hight128_e

; 150  :     }
; 151  :     // unnecessary IMHO, but it's part of the spec
; 152  :     x->q = ROTR64(x->q, 8);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, ecx
	shrd	ecx, eax, 8
	shr	eax, 8
	xor	edi, edi
	or	edi, ecx
	mov	DWORD PTR [esi], edi
	shl	edx, 24					; 00000018H
	or	edx, eax

; 153  : 
; 154  :     // mix key with 2nd 4 bytes
; 155  :     x->b[0] += wk[4]; x->b[2] ^= wk[5];

	mov	eax, DWORD PTR _keys$[ebp]
	mov	DWORD PTR [esi+4], edx
	mov	cl, BYTE PTR [eax+4]
	add	BYTE PTR [esi], cl
	mov	cl, BYTE PTR [eax+5]
	xor	BYTE PTR [esi+2], cl

; 156  :     x->b[4] += wk[6]; x->b[6] ^= wk[7];

	mov	cl, BYTE PTR [eax+6]
	add	BYTE PTR [esi+4], cl
	mov	al, BYTE PTR [eax+7]
	xor	BYTE PTR [esi+6], al
	pop	edi
	pop	esi
	pop	ebx

; 157  : }

	pop	ebp
	ret	0
_hight128_encrypt ENDP
_TEXT	ENDS
END
